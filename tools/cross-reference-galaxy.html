<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Cross-Reference Galaxy — The Unveiled Word</title>
<meta name="description" content="264,000 connections. 66 books. One galaxy. Explore every cross-reference in the Bible as an interactive 3D universe.">
<link rel="icon" href="../favicon.svg" type="image/svg+xml">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#010005;font-family:Georgia,serif}
canvas{width:100%;height:100%;display:block}

/* Cinematic intro */
#intro{position:fixed;inset:0;z-index:300;background:#010005;display:flex;flex-direction:column;
  align-items:center;justify-content:center;transition:opacity 2s}
#intro.gone{opacity:0;pointer-events:none}
#verse{color:rgba(197,150,12,0);font-style:italic;font-size:1.1rem;max-width:500px;text-align:center;
  line-height:1.8;transition:color 3s;letter-spacing:0.02em}
#verse.show{color:rgba(197,150,12,0.7)}
#verse cite{display:block;margin-top:12px;font-size:0.75rem;font-style:normal;color:rgba(197,150,12,0.4);
  letter-spacing:0.15em;text-transform:uppercase}
#skipbtn{position:fixed;bottom:30px;right:30px;z-index:301;color:rgba(255,245,220,0.2);font-size:0.65rem;
  cursor:pointer;letter-spacing:0.1em;border:none;background:none;font-family:Georgia,serif;
  transition:color 0.3s}
#skipbtn:hover{color:rgba(255,245,220,0.5)}

/* HUD */
#hud{position:fixed;top:0;left:0;right:0;z-index:100;pointer-events:none;
  padding:16px 20px;display:flex;justify-content:space-between;align-items:flex-start;
  opacity:0;transition:opacity 1.5s}
#hud.show{opacity:1}
#hud *{pointer-events:auto}
#hud a{color:rgba(197,150,12,0.4);text-decoration:none;font-size:0.7rem;transition:color 0.3s}
#hud a:hover{color:rgba(197,150,12,0.8)}
#htitle{color:rgba(197,150,12,0.5);font-size:0.7rem;letter-spacing:0.25em;text-transform:uppercase;
  font-family:'Cinzel',Georgia,serif}
#hstats{color:rgba(255,245,220,0.2);font-size:0.55rem;letter-spacing:0.08em;text-align:right}

/* Info panel */
#panel{position:fixed;bottom:0;left:0;right:0;z-index:100;text-align:center;
  background:linear-gradient(0deg,rgba(1,0,5,0.97) 0%,rgba(1,0,5,0.5) 70%,transparent 100%);
  padding:50px 28px 28px;transform:translateY(110%);transition:transform 0.7s cubic-bezier(0.25,1,0.5,1)}
#panel.show{transform:translateY(0)}
#bname{color:#c5960c;font-size:1.5rem;font-family:'Cinzel',Georgia,serif;margin-bottom:4px;
  text-shadow:0 0 30px rgba(197,150,12,0.3)}
#bdetail{color:rgba(255,245,220,0.45);font-size:0.75rem;margin-bottom:8px}
#bconns{color:rgba(255,245,220,0.3);font-size:0.65rem;line-height:1.8}

/* Legend */
#legend{position:fixed;top:50px;right:16px;z-index:100;opacity:0;transition:opacity 1.5s 2s}
#legend.show{opacity:0.4}
#legend:hover{opacity:0.9}
#legend div{display:flex;align-items:center;gap:6px;margin-bottom:3px;cursor:pointer}
.ldot{width:5px;height:5px;border-radius:50%}
.llbl{color:rgba(255,245,220,0.6);font-size:0.5rem;letter-spacing:0.04em}

/* Hint */
#hint{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);z-index:99;
  color:rgba(255,245,220,0);font-size:0.6rem;letter-spacing:0.12em;
  transition:color 1.5s 4s;pointer-events:none}
#hint.show{color:rgba(255,245,220,0.15)}

@media(max-width:768px){
  #verse{font-size:0.9rem;padding:0 24px}
  #legend{display:none}
  #bname{font-size:1.2rem}
}
</style>
</head>
<body>

<div id="intro">
  <p id="verse">
    &ldquo;In the beginning God created the heaven and the earth.
    And God said, Let there be light: and there was light.&rdquo;
    <cite>Genesis 1:1, 3</cite>
  </p>
</div>
<button id="skipbtn" onclick="skipIntro()">skip →</button>

<div id="hud">
  <a href="../">← The Unveiled Word</a>
  <div id="htitle">Cross-Reference Galaxy</div>
  <div id="hstats">66 Books · 264,673 References</div>
</div>

<div id="legend"></div>
<canvas id="c"></canvas>
<div id="panel">
  <div id="bname"></div>
  <div id="bdetail"></div>
  <div id="bconns"></div>
</div>
<div id="hint">drag to orbit · scroll to zoom · click a star</div>

<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}</script>
<script type="module">
import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
import {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';
import {RenderPass} from 'three/addons/postprocessing/RenderPass.js';
import {UnrealBloomPass} from 'three/addons/postprocessing/UnrealBloomPass.js';
import {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';

// ═══════════════════════════════════════════════
// PALETTE
// ═══════════════════════════════════════════════
const C={
  'Torah':0xd4a843,'History':0x9e7a2e,'Poetry':0x5b9bd5,
  'Major Prophets':0xc94040,'Minor Prophets':0xd4784a,
  'Gospels':0xf5deb3,'Church History':0x3db87a,
  "Paul's Letters":0x8e44ad,'General Letters':0x27ae60,'Apocalyptic':0xe74c3c
};

let scene,camera,renderer,composer,controls,clock;
let books=[],glows=[],labels=[],conns=[];
let flowParticles=[];
let shootingStars;
let selected=null,hovered=null;
let raycaster=new THREE.Raycaster(),mouse=new THREE.Vector2();
let data,introPhase=0,introTime=0;
let audioCtx,masterGain;

// ═══════════════════════════════════════════════
// PROCEDURAL TEXTURES
// ═══════════════════════════════════════════════
function starTex(){
  const c=document.createElement('canvas'),s=256;c.width=c.height=s;
  const x=c.getContext('2d'),h=s/2;
  // Soft radial core
  let g=x.createRadialGradient(h,h,0,h,h,h);
  g.addColorStop(0,'rgba(255,255,255,1)');
  g.addColorStop(0.02,'rgba(255,252,240,0.95)');
  g.addColorStop(0.06,'rgba(255,240,210,0.6)');
  g.addColorStop(0.15,'rgba(255,220,160,0.2)');
  g.addColorStop(0.35,'rgba(200,160,80,0.04)');
  g.addColorStop(0.6,'rgba(120,80,40,0.01)');
  g.addColorStop(1,'rgba(0,0,0,0)');
  x.fillStyle=g;x.fillRect(0,0,s,s);
  // 6-point diffraction spikes
  x.globalCompositeOperation='lighter';
  for(let a=0;a<6;a++){
    const ang=a*Math.PI/3;
    x.save();x.translate(h,h);x.rotate(ang);
    let sg=x.createLinearGradient(-h,0,h,0);
    sg.addColorStop(0,'rgba(255,255,255,0)');
    sg.addColorStop(0.35,'rgba(255,240,200,0.03)');
    sg.addColorStop(0.48,'rgba(255,255,255,0.1)');
    sg.addColorStop(0.5,'rgba(255,255,255,0.15)');
    sg.addColorStop(0.52,'rgba(255,255,255,0.1)');
    sg.addColorStop(0.65,'rgba(255,240,200,0.03)');
    sg.addColorStop(1,'rgba(255,255,255,0)');
    x.fillStyle=sg;x.fillRect(-h,-1.5,s,3);
    x.restore();
  }
  const t=new THREE.CanvasTexture(c);t.minFilter=THREE.LinearFilter;return t;
}

function ringTex(){
  const c=document.createElement('canvas');c.width=128;c.height=128;
  const x=c.getContext('2d');
  x.strokeStyle='rgba(197,150,12,0.15)';x.lineWidth=1;
  x.beginPath();x.arc(64,64,50,0,Math.PI*2);x.stroke();
  x.strokeStyle='rgba(197,150,12,0.07)';
  x.beginPath();x.arc(64,64,58,0,Math.PI*2);x.stroke();
  return new THREE.CanvasTexture(c);
}

// ═══════════════════════════════════════════════
// AMBIENT AUDIO (Web Audio API — no files needed)
// ═══════════════════════════════════════════════
function initAudio(){
  try{
    audioCtx=new(window.AudioContext||window.webkitAudioContext)();
    masterGain=audioCtx.createGain();
    masterGain.gain.value=0;
    masterGain.connect(audioCtx.destination);
    // Deep space drone — layered sine waves
    [55,82.5,110,165].forEach((freq,i)=>{
      const osc=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      osc.type=i===0?'sine':'sine';
      osc.frequency.value=freq;
      g.gain.value=[0.06,0.03,0.02,0.01][i];
      osc.connect(g);g.connect(masterGain);
      osc.start();
    });
    // Fade in
    masterGain.gain.linearRampToValueAtTime(0.4,audioCtx.currentTime+6);
  }catch(e){}
}

function playChime(freq){
  if(!audioCtx)return;
  try{
    const osc=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    osc.type='sine';osc.frequency.value=freq;
    g.gain.value=0.08;
    g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+2);
    osc.connect(g);g.connect(masterGain);
    osc.start();osc.stop(audioCtx.currentTime+2);
  }catch(e){}
}

// ═══════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════
async function init(){
  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(50,innerWidth/innerHeight,0.1,3000);
  camera.position.set(0,0,0.1); // Start at origin for intro

  renderer=new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true,powerPreference:'high-performance'});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=0.8;

  composer=new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene,camera));

  // Bloom
  const bloom=new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight),2.5,1.0,0.15);
  composer.addPass(bloom);

  // Film grain + vignette
  const filmShader={
    uniforms:{tDiffuse:{value:null},uTime:{value:0},uVignette:{value:0.4}},
    vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`uniform sampler2D tDiffuse;uniform float uTime,uVignette;varying vec2 vUv;
      float rand(vec2 co){return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453);}
      void main(){
        vec4 col=texture2D(tDiffuse,vUv);
        // Subtle film grain
        float grain=rand(vUv*uTime)*0.03;
        col.rgb+=grain-0.015;
        // Vignette
        float d=distance(vUv,vec2(0.5));
        col.rgb*=smoothstep(0.85,0.3,d*uVignette*2.0);
        // Slight color grade: warm highlights, cool shadows
        col.r+=col.r*0.05;
        col.b+=max(0.0,(0.15-col.r))*0.1;
        gl_FragColor=col;
      }`
  };
  const filmPass=new ShaderPass(filmShader);
  composer.addPass(filmPass);

  controls=new OrbitControls(camera,renderer.domElement);
  controls.enableDamping=true;controls.dampingFactor=0.03;
  controls.rotateSpeed=0.3;controls.zoomSpeed=0.5;
  controls.minDistance=10;controls.maxDistance=400;
  controls.autoRotate=true;controls.autoRotateSpeed=0.08;
  controls.enabled=false; // Disabled during intro

  // Load data
  const resp=await fetch('../data/galaxy_data.json');
  data=await resp.json();

  buildSpace();
  buildBooks();
  buildConnections();
  buildShootingStars();
  buildLegend();

  addEventListener('resize',onResize);
  renderer.domElement.addEventListener('click',onClick);
  renderer.domElement.addEventListener('mousemove',onHover);
  renderer.domElement.addEventListener('touchend',onTouch,{passive:true});

  // Start intro sequence
  clock=new THREE.Clock();
  introPhase=1;
  requestAnimationFrame(animate);
}

// ═══════════════════════════════════════════════
// DEEP SPACE
// ═══════════════════════════════════════════════
function buildSpace(){
  // Background stars — 8000 tiny points
  const N=8000,p=new Float32Array(N*3),s=new Float32Array(N),c=new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const th=Math.random()*Math.PI*2,ph=Math.acos(2*Math.random()-1),r=400+Math.random()*800;
    p[i*3]=r*Math.sin(ph)*Math.cos(th);p[i*3+1]=r*Math.sin(ph)*Math.sin(th);p[i*3+2]=r*Math.cos(ph);
    s[i]=Math.random()*1.5+0.2;
    const temp=Math.random();// Color temperature
    c[i*3]=0.9+temp*0.1;c[i*3+1]=0.85+temp*0.1;c[i*3+2]=0.8+temp*0.15;
  }
  const bg=new THREE.BufferGeometry();
  bg.setAttribute('position',new THREE.BufferAttribute(p,3));
  bg.setAttribute('size',new THREE.BufferAttribute(s,1));
  bg.setAttribute('color',new THREE.BufferAttribute(c,3));
  bg.userData={type:'bgstars'};
  const bm=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPR:{value:renderer.getPixelRatio()}},
    vertexShader:`attribute float size;varying vec3 vC;varying float vTw;uniform float uTime,uPR;
      void main(){vC=color;vTw=sin(uTime*2.0+position.x*0.03+position.z*0.03)*0.4+0.6;
      vec4 mv=modelViewMatrix*vec4(position,1.0);gl_Position=projectionMatrix*mv;
      gl_PointSize=size*uPR*(80.0/-mv.z);}`,
    fragmentShader:`varying vec3 vC;varying float vTw;
      void main(){float d=length(gl_PointCoord-0.5);if(d>0.5)discard;
      gl_FragColor=vec4(vC,smoothstep(0.5,0.0,d)*vTw*0.7);}`,
    transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,vertexColors:true
  });
  scene.add(new THREE.Points(bg,bm));

  // Nebula — 15000 particles, spiral + dust lanes
  const nn=15000,np=new Float32Array(nn*3),nc=new Float32Array(nn*3),ns=new Float32Array(nn);
  for(let i=0;i<nn;i++){
    const arm=Math.floor(Math.random()*3); // 3 spiral arms
    const armOff=arm*(Math.PI*2/3);
    const dist=Math.random()*200+5;
    const angle=armOff+dist*0.025+Math.random()*0.4;
    const spread=12+dist*0.12;
    np[i*3]=Math.cos(angle)*dist+(Math.random()-0.5)*spread;
    np[i*3+1]=(Math.random()-0.5)*25*Math.exp(-dist*0.005);
    np[i*3+2]=Math.sin(angle)*dist+(Math.random()-0.5)*spread;
    const t=Math.random();
    // Dust lane: darken particles near certain angles
    const dustAngle=Math.atan2(np[i*3+2],np[i*3]);
    const dustFactor=Math.abs(Math.sin(dustAngle*2))<0.15?0.1:1;
    if(t<0.5){nc[i*3]=0.35*dustFactor;nc[i*3+1]=0.18*dustFactor;nc[i*3+2]=0.05*dustFactor;}
    else if(t<0.8){nc[i*3]=0.12*dustFactor;nc[i*3+1]=0.1*dustFactor;nc[i*3+2]=0.3*dustFactor;}
    else{nc[i*3]=0.2*dustFactor;nc[i*3+1]=0.08*dustFactor;nc[i*3+2]=0.12*dustFactor;}
    ns[i]=Math.random()*5+1;
  }
  const ng=new THREE.BufferGeometry();
  ng.setAttribute('position',new THREE.BufferAttribute(np,3));
  ng.setAttribute('color',new THREE.BufferAttribute(nc,3));
  ng.setAttribute('size',new THREE.BufferAttribute(ns,1));
  const nm=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPR:{value:renderer.getPixelRatio()}},
    vertexShader:`attribute float size;varying vec3 vC;uniform float uTime,uPR;
      void main(){vC=color;vec3 p=position;
      p.y+=sin(uTime*0.06+position.x*0.005)*2.0;
      p.x+=cos(uTime*0.03+position.z*0.003)*1.5;
      vec4 mv=modelViewMatrix*vec4(p,1.0);gl_Position=projectionMatrix*mv;
      gl_PointSize=size*uPR*(250.0/-mv.z);}`,
    fragmentShader:`varying vec3 vC;
      void main(){float d=length(gl_PointCoord-0.5);if(d>0.5)discard;
      gl_FragColor=vec4(vC,smoothstep(0.5,0.05,d)*0.04);}`,
    transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,vertexColors:true
  });
  const neb=new THREE.Points(ng,nm);neb.userData.type='nebula';
  scene.add(neb);
}

// ═══════════════════════════════════════════════
// SHOOTING STARS
// ═══════════════════════════════════════════════
function buildShootingStars(){
  const N=6;
  const geo=new THREE.BufferGeometry();
  const pos=new Float32Array(N*6); // 2 vertices per line (start + end)
  const vel=[];
  for(let i=0;i<N;i++){
    pos[i*6]=pos[i*6+3]=(Math.random()-0.5)*600;
    pos[i*6+1]=pos[i*6+4]=Math.random()*200+50;
    pos[i*6+2]=pos[i*6+5]=(Math.random()-0.5)*600;
    vel.push({
      x:(Math.random()-0.5)*8,
      y:-(Math.random()*3+2),
      z:(Math.random()-0.5)*8,
      life:0,maxLife:Math.random()*1.5+0.5,
      cooldown:Math.random()*15+5
    });
  }
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  const mat=new THREE.LineBasicMaterial({color:0xffffff,transparent:true,opacity:0,blending:THREE.AdditiveBlending,depthWrite:false});
  shootingStars={geo,pos,vel,mesh:new THREE.LineSegments(geo,mat)};
  scene.add(shootingStars.mesh);
}

// ═══════════════════════════════════════════════
// BOOKS
// ═══════════════════════════════════════════════
function buildBooks(){
  const tex=starTex();
  const secs=Object.keys(data.sections);
  // Major books get orbital rings
  const majorBooks=['Gen','Ps','Isa','Matt','Rev','Rom','Exod','Jer','Ezek','John','Heb'];

  data.books.forEach((bk,i)=>{
    const si=secs.indexOf(bk.section);
    const arr=data.sections[bk.section];
    const bi=arr.indexOf(bk.abbr);
    const bn=arr.length;

    // Spiral placement with 3 arms
    const arm=si%3;
    const armBase=arm*(Math.PI*2/3);
    const progress=(si*bn+bi)/(data.books.length);
    const dist=25+progress*130;
    const angle=armBase+progress*Math.PI*3.5+(bi/bn)*0.6;
    const y=Math.sin(angle*1.8)*10+(Math.random()-0.5)*6;
    const x=Math.cos(angle)*dist;
    const z=Math.sin(angle)*dist;

    const sz=Math.max(0.2,Math.pow(bk.chapters,0.3)*0.3);
    const col=C[bk.section]||0xc5960c;

    // Core mesh (tiny, bright white)
    const core=new THREE.Mesh(
      new THREE.SphereGeometry(sz*0.5,12,12),
      new THREE.MeshBasicMaterial({color:0xffffff})
    );
    core.position.set(x,y,z);
    core.userData={bk,idx:i,sz};
    scene.add(core);
    books.push(core);

    // Star glow sprite
    const gm=new THREE.SpriteMaterial({
      map:tex,color:col,transparent:true,opacity:0.6,
      blending:THREE.AdditiveBlending,depthWrite:false
    });
    const glow=new THREE.Sprite(gm);
    const gs=sz*7+1.5;
    glow.scale.set(gs,gs,1);glow.position.copy(core.position);
    glow.userData={idx:i,bs:gs,bo:0.6};
    scene.add(glow);glows.push(glow);

    // Orbital ring for major books
    if(majorBooks.includes(bk.abbr)){
      const rg=new THREE.RingGeometry(sz*4,sz*4.3,48);
      const rm=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.08,side:THREE.DoubleSide,blending:THREE.AdditiveBlending,depthWrite:false});
      const ring=new THREE.Mesh(rg,rm);
      ring.position.copy(core.position);
      ring.rotation.x=Math.PI*0.4;
      ring.userData={type:'ring',idx:i};
      scene.add(ring);
    }

    // Label (hidden by default)
    const lbl=mkLbl(bk.name);
    lbl.position.set(x,y+sz*5+2.5,z);
    lbl.material.opacity=0;
    lbl.userData={idx:i,type:'label'};
    scene.add(lbl);labels.push(lbl);
  });
}

function mkLbl(t){
  const c=document.createElement('canvas');c.width=256;c.height=48;
  const x=c.getContext('2d');
  x.font='500 18px Georgia,serif';x.textAlign='center';x.textBaseline='middle';
  x.shadowColor='rgba(0,0,0,1)';x.shadowBlur=6;
  x.fillStyle='rgba(255,245,220,0.9)';x.fillText(t,128,24);
  const tex=new THREE.CanvasTexture(c);tex.minFilter=THREE.LinearFilter;
  const s=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false}));
  s.scale.set(9,1.8,1);return s;
}

// ═══════════════════════════════════════════════
// CONNECTIONS
// ═══════════════════════════════════════════════
function buildConnections(){
  const top=data.connections.slice(0,500);
  const max=top[0]?.count||1;

  top.forEach(cn=>{
    const fb=data.books.find(b=>b.abbr===cn.from);
    const tb=data.books.find(b=>b.abbr===cn.to);
    if(!fb||!tb)return;
    const fm=books[fb.index],tm=books[tb.index];

    const str=cn.count/max;
    const s=fm.position.clone(),e=tm.position.clone();
    const m=s.clone().add(e).multiplyScalar(0.5);
    m.y+=4+str*18;

    const curve=new THREE.QuadraticBezierCurve3(s,m,e);
    const pts=curve.getPoints(28);
    const geo=new THREE.BufferGeometry().setFromPoints(pts);

    const c1=new THREE.Color(C[fb.section]||0xc5960c);
    const c2=new THREE.Color(C[tb.section]||0xc5960c);
    const vc=new Float32Array(pts.length*3);
    for(let j=0;j<pts.length;j++){
      const t=j/(pts.length-1);
      const cc=c1.clone().lerp(c2,t);
      vc[j*3]=cc.r;vc[j*3+1]=cc.g;vc[j*3+2]=cc.b;
    }
    geo.setAttribute('color',new THREE.BufferAttribute(vc,3));

    const bo=Math.max(0.01,str*0.1);
    const mat=new THREE.LineBasicMaterial({
      vertexColors:true,transparent:true,opacity:bo,
      blending:THREE.AdditiveBlending,depthWrite:false
    });
    const line=new THREE.Line(geo,mat);
    line.userData={from:cn.from,to:cn.to,count:cn.count,bo,curve};
    scene.add(line);conns.push(line);
  });
}

// ═══════════════════════════════════════════════
// ENERGY FLOW PARTICLES (appear on selection)
// ═══════════════════════════════════════════════
function spawnFlow(bookAbbr){
  clearFlow();
  const related=conns.filter(l=>l.userData.from===bookAbbr||l.userData.to===bookAbbr).slice(0,30);
  related.forEach(line=>{
    const curve=line.userData.curve;
    if(!curve)return;
    const col=new THREE.Color(C[data.books.find(b=>b.abbr===bookAbbr)?.section]||0xc5960c);
    // Create flowing particles along this curve
    for(let i=0;i<8;i++){
      const geo=new THREE.SphereGeometry(0.15,6,6);
      const mat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.8});
      const m=new THREE.Mesh(geo,mat);
      m.userData={curve,t:Math.random(),speed:0.3+Math.random()*0.3,reverse:line.userData.to===bookAbbr};
      scene.add(m);
      flowParticles.push(m);
    }
  });
}

function clearFlow(){
  flowParticles.forEach(p=>{scene.remove(p);p.geometry.dispose();p.material.dispose()});
  flowParticles=[];
}

function updateFlow(dt){
  flowParticles.forEach(p=>{
    p.userData.t+=dt*p.userData.speed*(p.userData.reverse?-1:1);
    if(p.userData.t>1)p.userData.t-=1;
    if(p.userData.t<0)p.userData.t+=1;
    const pt=p.userData.curve.getPoint(p.userData.t);
    p.position.copy(pt);
    // Pulse opacity
    p.material.opacity=0.4+Math.sin(p.userData.t*Math.PI)*0.5;
  });
}

// ═══════════════════════════════════════════════
// LEGEND
// ═══════════════════════════════════════════════
function buildLegend(){
  const el=document.getElementById('legend');
  for(const[n,col] of Object.entries(C)){
    const d=document.createElement('div');
    const dot=document.createElement('span');dot.className='ldot';
    dot.style.background='#'+new THREE.Color(col).getHexString();
    dot.style.boxShadow='0 0 4px #'+new THREE.Color(col).getHexString();
    const lbl=document.createElement('span');lbl.className='llbl';lbl.textContent=n;
    d.append(dot,lbl);el.appendChild(d);
  }
}

// ═══════════════════════════════════════════════
// INTRO SEQUENCE
// ═══════════════════════════════════════════════
// Phase 1: Black screen, verse fades in (0-3s)
// Phase 2: Verse visible (3-6s)
// Phase 3: Camera pulls back, stars appear (6-9s)
// Phase 4: Full galaxy visible, controls enabled (9s+)

function updateIntro(t){
  if(introPhase===0)return;

  if(introPhase===1){
    // Show verse
    if(t>0.5) document.getElementById('verse').classList.add('show');
    if(t>4){introPhase=2;introTime=t;}
  }
  if(introPhase===2){
    // Hold verse, then start fading
    if(t-introTime>2){introPhase=3;introTime=t;}
  }
  if(introPhase===3){
    // Camera pulls back from origin to galaxy view
    const p=Math.min(1,(t-introTime)/4);
    const ease=1-Math.pow(1-p,3);
    camera.position.set(0,ease*60,ease*160);
    controls.target.set(0,0,0);
    renderer.toneMappingExposure=0.8*ease;

    if(p>0.3){
      document.getElementById('intro').classList.add('gone');
      document.getElementById('skipbtn').style.display='none';
    }
    if(p>0.7){
      document.getElementById('hud').classList.add('show');
      document.getElementById('legend').classList.add('show');
      document.getElementById('hint').classList.add('show');
    }
    if(p>=1){
      introPhase=0;
      controls.enabled=true;
      initAudio();
    }
  }
}

window.skipIntro=function(){
  introPhase=0;
  camera.position.set(0,60,160);controls.target.set(0,0,0);
  renderer.toneMappingExposure=0.8;
  controls.enabled=true;
  document.getElementById('intro').classList.add('gone');
  document.getElementById('skipbtn').style.display='none';
  document.getElementById('hud').classList.add('show');
  document.getElementById('legend').classList.add('show');
  document.getElementById('hint').classList.add('show');
  initAudio();
};

// ═══════════════════════════════════════════════
// INTERACTION
// ═══════════════════════════════════════════════
function onClick(e){
  if(introPhase)return;
  mouse.x=(e.clientX/innerWidth)*2-1;mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  // Bigger hit area: check glow sprites
  const hits=raycaster.intersectObjects(books);
  if(hits.length)selectBook(hits[0].object.userData.idx);
  else deselect();
}

function onTouch(e){
  if(introPhase||!e.changedTouches.length)return;
  const t=e.changedTouches[0];
  mouse.x=(t.clientX/innerWidth)*2-1;mouse.y=-(t.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObjects(books);
  if(hits.length)selectBook(hits[0].object.userData.idx);
}

function onHover(e){
  if(introPhase)return;
  mouse.x=(e.clientX/innerWidth)*2-1;mouse.y=-(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObjects(books);
  if(hits.length){
    const idx=hits[0].object.userData.idx;
    if(hovered!==idx){
      if(hovered!==null&&hovered!==(selected?.userData?.idx))labels[hovered].material.opacity=0;
      labels[idx].material.opacity=0.9;
      hovered=idx;
    }
    renderer.domElement.style.cursor='pointer';
  }else{
    if(hovered!==null&&hovered!==(selected?.userData?.idx))labels[hovered].material.opacity=0;
    hovered=null;
    renderer.domElement.style.cursor='grab';
  }
}

function selectBook(idx){
  const bk=data.books[idx],mesh=books[idx];
  if(selected)deselect();
  selected=mesh;controls.autoRotate=false;

  // Camera
  const tgt=mesh.position.clone();
  animCam(tgt.clone().add(new THREE.Vector3(3,6,18)),tgt);

  // Audio
  const notes=[261.6,329.6,392.0,523.2];
  playChime(notes[idx%4]);

  // Find connections
  const bkConns=data.connections.filter(c=>c.from===bk.abbr||c.to===bk.abbr).sort((a,b)=>b.count-a.count);
  const connSet=new Set(bkConns.map(c=>c.from===bk.abbr?c.to:c.from));
  const total=bkConns.reduce((s,c)=>s+c.count,0);

  // Highlight
  conns.forEach(l=>{
    if(l.userData.from===bk.abbr||l.userData.to===bk.abbr) l.material.opacity=Math.min(0.7,l.userData.bo*12);
    else l.material.opacity=0.002;
  });
  glows.forEach(g=>{
    const gi=g.userData.idx;
    if(gi===idx){g.material.opacity=1;g.scale.setScalar(g.userData.bs*2);}
    else if(connSet.has(data.books[gi]?.abbr)){g.material.opacity=g.userData.bo*0.8;}
    else{g.material.opacity=0.04;}
  });
  books.forEach((m,i)=>{
    m.material.color.setHex(i===idx?0xffffff:connSet.has(data.books[i].abbr)?0xcccccc:0x222222);
  });
  labels.forEach((l,i)=>{l.material.opacity=i===idx?1:connSet.has(data.books[i]?.abbr)?0.4:0;});

  // Spawn energy flow
  spawnFlow(bk.abbr);

  // UI
  document.getElementById('bname').textContent=bk.name;
  document.getElementById('bdetail').textContent=
    `${bk.chapters} chapters · ${bk.section} · ${total.toLocaleString()} cross-references`;
  const top8=bkConns.slice(0,8).map(c=>{
    const o=c.from===bk.abbr?c.to:c.from;
    return `${data.books.find(b=>b.abbr===o)?.name||o} (${c.count.toLocaleString()})`;
  });
  document.getElementById('bconns').textContent=top8.join(' · ');
  document.getElementById('panel').classList.add('show');
  document.getElementById('hint').style.opacity='0';
}

function deselect(){
  if(!selected)return;selected=null;controls.autoRotate=true;
  conns.forEach(l=>l.material.opacity=l.userData.bo);
  glows.forEach(g=>{g.material.opacity=g.userData.bo;g.scale.setScalar(g.userData.bs)});
  books.forEach(m=>m.material.color.setHex(0xffffff));
  labels.forEach(l=>l.material.opacity=0);
  clearFlow();
  document.getElementById('panel').classList.remove('show');
}

// ── Camera ──
let camA=null;
function animCam(p,l){camA={sp:camera.position.clone(),ep:p,st:controls.target.clone(),et:l,t0:clock.getElapsedTime(),d:2};}
function updCam(t){
  if(!camA)return;let p=Math.min(1,(t-camA.t0)/camA.d);
  if(p>=1){p=1;camA=null;}p=1-Math.pow(1-p,4);
  camera.position.lerpVectors(camA.sp,camA.ep,p);
  controls.target.lerpVectors(camA.st,camA.et,p);
}

// ═══════════════════════════════════════════════
// ANIMATE
// ═══════════════════════════════════════════════
function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();
  const dt=clock.getDelta();

  updateIntro(t);
  updCam(t);
  controls.update();

  // Pulse glows
  if(!selected){
    glows.forEach((g,i)=>{
      const p=Math.sin(t*1.2+i*0.8)*0.12+1;
      g.scale.setScalar(g.userData.bs*p);
    });
  }

  // Rotate orbital rings
  scene.traverse(o=>{
    if(o.userData?.type==='ring')o.rotation.z=t*0.2+o.userData.idx*0.5;
  });

  // Update nebula & stars
  scene.traverse(o=>{
    if(o.isPoints&&o.material.uniforms?.uTime)o.material.uniforms.uTime.value=t;
    if(o.userData?.type==='nebula')o.rotation.y=t*0.003;
  });

  // Shooting stars
  if(shootingStars){
    const p=shootingStars.pos,v=shootingStars.vel;
    let dirty=false;
    v.forEach((vel,i)=>{
      vel.cooldown-=dt;
      if(vel.cooldown>0){
        p[i*6]=p[i*6+3];p[i*6+1]=p[i*6+4];p[i*6+2]=p[i*6+5];
        return;
      }
      vel.life+=dt;
      if(vel.life>vel.maxLife){
        vel.life=0;vel.cooldown=Math.random()*12+4;vel.maxLife=Math.random()*1+0.4;
        const a=Math.random()*Math.PI*2,r=150+Math.random()*200;
        p[i*6]=p[i*6+3]=Math.cos(a)*r;
        p[i*6+1]=p[i*6+4]=Math.random()*100+30;
        p[i*6+2]=p[i*6+5]=Math.sin(a)*r;
        vel.x=(Math.random()-0.5)*10;vel.y=-(Math.random()*4+2);vel.z=(Math.random()-0.5)*10;
        return;
      }
      // Trail: head moves, tail stays
      p[i*6+3]+=vel.x*dt*60;p[i*6+4]+=vel.y*dt*60;p[i*6+5]+=vel.z*dt*60;
      // Tail catches up slowly
      p[i*6]+=(p[i*6+3]-p[i*6])*dt*4;
      p[i*6+1]+=(p[i*6+4]-p[i*6+1])*dt*4;
      p[i*6+2]+=(p[i*6+5]-p[i*6+2])*dt*4;
      dirty=true;
    });
    if(dirty){
      shootingStars.geo.attributes.position.needsUpdate=true;
      const hasActive=v.some(vel=>vel.cooldown<=0&&vel.life>0&&vel.life<vel.maxLife);
      shootingStars.mesh.material.opacity=hasActive?0.6:0;
    }
  }

  // Energy flow
  updateFlow(dt);

  // Film grain time
  composer.passes.forEach(p=>{if(p.uniforms?.uTime)p.uniforms.uTime.value=t;});

  composer.render();
}

function onResize(){
  camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);composer.setSize(innerWidth,innerHeight);
}

init();
</script>
</body>
</html>
